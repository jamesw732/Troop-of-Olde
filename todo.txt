Implementation todo list.

===========================ACTIVE===============================
Refactor Character/Controllers to not carry pretty much all of the game logic.
High-level todo list:
Server:
Make Character single-responsibility:
- ItemsManager
- StatManager
Move System/Manager-level logic away from World
- Character creation?
- CleanupManager
Optimize systems/managers
- EffectSystem networking and loop
- CombatSystem networking and loop


Client:
Make Controllers single-responsibility:
- Remove kill... add CleanupManager? DeathManager will exist on a layer above this, but
for now deaths are just cleanups. Seems pretty good.
- Organize parts of Controllers so that PlayerController and NPCController can be merged.
Is it even correct to merge PlayerController and NPCController?
I think yes, at least on the level of "LERP between previous and target position" since that
functionality is shared. They're not being merged in the sense that their behavior will be
identical, just that this one layer of functionality should be shared between them.
    - Client's inputs which update velocity_components["keyboard"] and rotation stuff
    - Server's inputs which update displacement_components["server_offset"] and rot_offset
    - Physics engine which computes the predicted target position/rotation
    - Lerp engine which just interpolates character position between physics update ticks
    - The camera's controller which basically just handles collision
  - Potential solution:
    - CharacterController, per-Character class that processes physics on "globally" accessible
    velocity components to obtain a target position/rotation, and lerps every frame.
    - CameraController, singleton class that handles camera collision. Inputhandler would interface
    to this for inputs.
    - MovementInput, singleton class that InputHandler interfaces to for movement input logic,
    simply writes velocity components and rotation stuff.

Refactor controllers into a System
- Make MovementSystem class
Make Characters single-responsibility:
- ItemsManager (move item functionality from Character)
- StatSystem
Move System/Manager-level functionality away from World:
- Character creation?
- CleanupManager
Optimize systems/managers
- CombatManager probably needs to do more, currently being bypassed in some places
- Should AnimationSystem just be a wrapper for CharacterAnimator (like it currently is)?
Seems unnecessary, could just bake the logic into AnimationSystem. Maybe rename CharacterAnimator
to AnimationState?


As part of making Characters single-responsibility, I should plan to separate all attrs that
are isolatable to a single System, but nothing more. This should keep the Character's scope pretty
small while not obfuscating any behavior.


EffectSystem Notes:
- Need to make sure that deleting Effects removes them from inst_id_to_effect.
Move Effect deletion into EffectSystem
- Want to make the tick_effects loop more efficient.
    - Can probably just loop over inst_id_to_effect.values(), at least for now.
    But will need to check if the Effect has actually been applied
    - Would prefer to send fewer individual network calls. Send all messages and cbstate updates
    as homogeneous lists... probably time to give up on separating player/npc combat states.
    Would it be good to somehow merge CombatSystem and EffectSystem network updates?


CombatSystem/Manager Notes:
- Could probably stand to re-organize the interface
- Don't need to loop over all characters, only the ones that are actually in combat.
- Would be nice to reduce number of network requests sent. One per attack attempt per client
seems reasonable. This is a somewhat lower priority (for now) optimization.


Controllers notes:
Once controllers are single-responsibility, refactor them into MovementSystem, don't attach to
single Character instances and instead operate on all Characters.


StatManager Notes:
- This will provide an interface for modifying Character stats, which currently is split between
Character and StatsState.
- If shared interface is heavy, could move it into a new stats.py file. But it shouldn't stay in
Character, because that's the exact problem we're trying to solve here... make classes more
single-responsibility.








===================================NEXT================================================
Finish adding animations.
Animation checklist:
Immediate Must Haves:
- Add weapon models/handling
- Spellcasting
- Death
Eventual Must Haves:
- Jumping animation
- Backwards walk animation
Nice to haves:
- Sideways walk animations


Weapon model todo list:
- Client should get access to other clients' equipment
- Animations need to depend on weapons
- 2h weapons should have different animations

Notes:
I think client updates for npcs can be parallel to the current items update after moving an item.
Rename remote_update_equipment_inventory to remote_pc_item_move_update, and
make it include the new cbstate.
Also add a remote_npc_item_move_update, which accepts an NPCCombatState and
equipment, but not inventory. Call this for all other connections.
The equipment update, defined in controllers, could probably just be for the
animator, at least for now.






Once animations are done, I want to continue to make some bigger moves.

- Clean up networking code and game logic. Basically, for every functionality implemented,
go through it from start to finish and think about what data needs to be transferred.
The necessary questions for each input are:
    What does my client need to do?
    What data does my client need to send to the server?
    What does the server need to do?
    What does the server need to send back to my client?
    What does the server need to send back to other clients?
    What does my client need to do in response?
    What do other clients have to do in response?
Expected changes from thinking about this:
    - No more broadcast_cbstate_update, in general much more intentional network responses
    - Proper split between different types of Characters, especially client-side

- Flesh out the UI. Add enemy status window (health/energy/effects), add effects to own
status window, add tooltips to items and powers.
- Add respawns and looting.
- Add NPC AI logic
- Fix networking neglects, including disconnects, animations, etc.



=========================================BACKLOG=================================================
Generic Code cleanup:
- Are the client-side on_destroy callbacks necessary?
    Pros:
        - Allows destroys to be initiated by controllers
        - Makes network code not depend directly on destroy logic
        - Consistent with server, where on_destroy is more essential
    Cons:
        - Makes the destroy process more opaque, after all the reason the client
        should destroy objects is because the server told it to.


Networking:
- Add sequence count to network calls where order of arrival matters, for example
skill level ups and receiving containers.
- Login sequence should be more back and forth, it shouldn't just be the server spitting out
different responses and hoping they arrive in order.
- Will eventually need to encapsulate server and client creation in Server and Client classes. 
- Consider moving network to be client/server dependent.
- Need to fix disconnect, I think can just destroy the controller and character?


Player Controller:
- Jumping is incorrect, not sure exactly what's wrong with it.
- Camera should probably be handled separately from PlayerController.
- Consider making PlayerController a singleton not attached to world.


Physics:
- Implement momentum, make it be a list of the 5 most recent keyboard movement vectors. They are
averaged and added as a displacement factor if no keyboard inputs for that physics tick.
- Considering adding more raycasts besides just at the feet. Will be necessary for stairs
- Use a loop for raycasts to not collide through concave intersections
- Improve wall collision logic, namely removing ability to jump up walls.


Combat:
Neglected formulas:
- probability to upgrade skill
- hit chance/accuracy
- dual wield attack rate

Incomplete subcontent:
- Weapon types
- Effects/powers, not nearly enough types at the moment.

Incomplete stat implementations:
- Energy
- Armor
- All the modifiers
- Regeneration
- Hardiness


Character:
- Refine the split between different types of characters.
Need to handle differences between own player character/other player character/npc



Powers:
- Add a channeled power.
- Need to add client-side reconciliation for powers
- Add a UI window showing persistent powers
- Make persistent powers unique per character
- Improve powers/effects database, will need to think about this a lot
- Bug happens when trying to use a queued power with no energy


UI:
UI is quite incomplete, there is a lot of helpful information that should be tracked by the UI:
- player's target's health
- in combat/not
- persistent effects

Some missing functionality
- Loot window
- Hover and right click tooltips, which will be the primary visual guide for the UI
- Swapping of action bar slots
- Destroying items

Bugs
- Scrolling with mousewheel while scrollbar is full results in division by zero
- Transparency handling for the game window is buggy since the scrollbar has its own collider.
Basically, the current handling for mouse enter/exit is fragile - entering on and exiting from a
child entity with a collider doesn't correctly trigger the transparency change. Unclear how to fix
this, worst case can remove the collider.
- There's also a bug with new text entering the game window with the wrong transparency. I think
text should probably be ignored by set_alpha altogether.

Architecture:
- Pull functions out from UI __init__'s so that the UI class has more control over what
happens during creation. Mapping container ids to ItemFrames is a good example of this,
that will need to be done for all future containers, so the UI should have a function for
doing that.
- ItemIcon should eventually be pulled out of items_window.py once items exist outside of 
the player items window. They should then be created by UI, which should also now store
inst_id_to_item_icon.


Database:
Move to an SQL database instead of using json.


Documentation:
Ideally, I want some big tex files that document everything important, such as code architecture,
formulas used, philosophy, game mechanics, class content. These files essentially serves as the
implementation definition.

Also, should eventually move things onto Github issues once the repository is more stable.


Tests:
Tests currently are very broken and limited in functionality. Codebase is too volatile to sustain tests
at the moment, once things are more stable it will be a good idea to test things.
Could also consider test-driven development, where I should understand the interface of the code before
writing the code.



=====================================DISTANT==============================================
- Save system
- Character/item models/textures
- World building; terrain, textures, buildings
- NPC logic
- Music
- Icons
- UI Art


Considering move to C/C++ once prototype is finished.
Would need to consider replacements for everything.
- Rendering: Raylib
- Scene graph: Optional, seems fairly simple to implement if desired
- Networking: Enet or Yojimbo
- Animation: Raylib, but would need to build things from the ground up, probably from custom
shaders
- Physics: Raylib raycasting
- Entity Component System: Self built
