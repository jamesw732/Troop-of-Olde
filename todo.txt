Implementation todo list.

===========================ACTIVE===============================
Finish adding animations.
Animation checklist:
- Add weapon models
- Combat animation (weapons)
- Jumping animation
- Backwards walk animation
- Sideways walk animations?
- Death


Two parts to adding weapons:
- Adding/removing them to/from the scene
- Managing animations

Just work on adding/removing weapons to/from the scene for now.
Will need to consider how it ties into the rest of the procedure for moving items.
This procedure is:
- UI processes input to move. If it's an auto equip/unequip, then we just send a
request to server to auto equip/unequip this item. If it was a manual move, we do some
work to validate whether the move is valid or not, and then send a networking request.
The item is never moved client-side.
- Server-side, we call one of the auto functions, which essentially just call full_item_move.
Then, we send back the new updated container and update the character's stats to all clients.
We don't currently send the equipment to other players, but this will need to change. Will
require storing equipment on NPCs, which shouldn't be too bad, but will require updating
states.
- Server calls remote_update_container, which just overwrites all items in the
corresponding container and updates the UI icons. Realistically, the graphical item model
logic could go in here, but it'll probably be cleaner to include it as part of the
controllers.



Suggestions to improve the process:
In Item:
- option_to_meth probably shouldn't be in Item
- Item shouldn't store its icon, instead store a separate map from item inst_id to ItemIcon.
For now, this map can be in ItemsWindow because ItemIcons don't exist outside of ItemsWindow.
- Rather than requiring "slots" in items.json, should make this optional, and implement
an automatic population. Should also rename it to "equippable_slots" to be more descriptive.
Should also add an "exclude_equip_slots" field, for example signifying that equipping a 2H
removes the offhand.

Item move logic:
- I really wish there wasn't a bunch of hardcoded "equipment" cases in full_item_move.
- full_item_move is basically doing three independent things, it's:
    1. Computing the consequences of this move
    2. Checking that the consequences are valid
    3. Performing the consequences.
I think it would be good to split these up into different functions.
So, what should this function look like?
    - Determine which items we want to move
    - For each item and its destination container, determine both the valid slots to move
    to and the slots which this item forces an unequip for. This should be done in a new
    function, and it will return a tuple (valid slots, exclude slots). The logic is if
    equipping, look in item for valid/exclude, and if not, return all indices of
    destination container for valid slots and an empty list for exclude.
    Hardest case to handle will be equipping an offhand while wearing a 2h weapon.
    - Compute the consequences as before. The logic will be basically the same, but rather
    than hard-coded logic, it will depend on the returned valid/exclude slots. Can make
    get_first_empty depend on valid slots rather than an Item. Should be quite a bit shorter.
    - Check whether all the consequences of the move are valid.
    - Perform the moves if all valid.
Bonus points if I can get internal_autoequip to not be hardcoded in terms of equipment.

In items_window.py:
- handle_release_icon should use new logic to determine if a move is valid.


===================================NEXT================================================
Once animations are done, I want to continue to make some bigger moves.

- Clean up networking code and game logic. Basically, for every functionality implemented,
go through it from start to finish and think about what data needs to be transferred.
The necessary questions for each input are:
    What does my client need to do?
    What data does my client need to send to the server?
    What does the server need to do?
    What does the server need to send back to my client?
    What does the server need to send back to other clients?
    What does my client need to do in response?
    What do other clients have to do in response?
- Flesh out the UI. Add enemy status window (health/energy/effects), add effects to own
status window, add tooltips to items and powers.
- Add respawns and looting.
- Add NPC AI logic
- Fix networking neglects, including disconnects, animations, etc.



=========================================BACKLOG=================================================
Generic Code cleanup:


Networking:
- Add sequence count to network calls where order of arrival matters, for example
skill level ups and receiving containers.
- Login sequence should be more back and forth, it shouldn't just be the server spitting out
different responses and hoping they arrive in order.
- Will eventually need to encapsulate server and client creation in Server and Client classes. 
- Consider moving network to be client/server dependent.
- Need to fix disconnect, I think can just destroy the controller and character?


Player Controller:
- Jumping is incorrect, not sure exactly what's wrong with it.
- Camera should probably be handled separately from PlayerController.
- Consider making PlayerController a singleton not attached to world.


Physics:
- Implement momentum, make it be a list of the 5 most recent keyboard movement vectors. They are
averaged and added as a displacement factor if no keyboard inputs for that physics tick.
- Considering adding more raycasts besides just at the feet. Will be necessary for stairs
- Use a loop for raycasts to not collide through concave intersections
- Improve wall collision logic, namely removing ability to jump up walls.


Combat:
Neglected formulas:
- probability to upgrade skill
- hit chance/accuracy
- dual wield attack rate

Incomplete subcontent:
- Weapon types
- Effects/powers, not nearly enough types at the moment.

Incomplete stat implementations:
- Energy
- Armor
- All the modifiers
- Regeneration
- Hardiness


Character:
- Stats object should probably have a more elegant interaction with Characters. Would
be nice to unify Stats with all the different Effect types.
- Would really like to not have so many arguments to Character, would it be possible
to make a new State which combines existing States? Probably...
- Need to fix default inventory/equipment



Powers:
- Add a channeled power.
- Need to add client-side reconciliation for powers
- Add a UI window showing persistent powers
- Make persistent powers unique per character
- Improve powers/effects database, will need to think about this a lot
- Bug happens when trying to use a queued power with no energy


UI:
UI is quite incomplete, there is a lot of helpful information that should be tracked by the UI:
- player's target's health
- in combat/not
- persistent effects

Some missing functionality
- Loot window
- Hover and right click tooltips, which will be the primary visual guide for the UI
- Swapping of action bar slots
- Destroying items

Bugs
- Scrolling with mousewheel while scrollbar is full results in division by zero
- Transparency handling for the game window is buggy since the scrollbar has its own collider.
Basically, the current handling for mouse enter/exit is fragile - entering on and exiting from a
child entity with a collider doesn't correctly trigger the transparency change. Unclear how to fix
this, worst case can remove the collider.
- There's also a bug with new text entering the game window with the wrong transparency. I think
text should probably be ignored by set_alpha altogether.

Architecture:
- Pull functions out from UI __init__'s so that the UI class has more control over what
happens during creation. Mapping container ids to ItemFrames is a good example of this,
that will need to be done for all future containers, so the UI should have a function for
doing that.
- ItemIcon should eventually be pulled out of items_window.py once items exist outside of 
the player items window. They should then be created by UI, which should also now store
inst_id_to_item_icon.


Database:
Move to an SQL database instead of using json.


Documentation:
Ideally, I want some big tex files that document everything important, such as code architecture,
formulas used, philosophy, game mechanics, class content. These files essentially serves as the
implementation definition.

Also, should eventually move things onto Github issues once the repository is more stable.


Tests:
Tests currently are very broken and limited in functionality. Codebase is too volatile to sustain tests
at the moment, once things are more stable it will be a good idea to test things.
Could also consider test-driven development, where I should understand the interface of the code before
writing the code.



=====================================DISTANT==============================================
- Save system
- Character/item models/textures
- World building; terrain, textures, buildings
- NPC logic
- Music
- Icons
- UI Art
