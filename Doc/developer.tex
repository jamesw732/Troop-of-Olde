\documentclass{article}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{hyperref}
\usepackage{xparse}
\usepackage{amsmath}

\NewDocumentCommand{\codeword}{v}{%
\texttt{{#1}}%
}

\title{Troop of Olde Documentation}
\author{James Westbrook}

\begin{document}
\maketitle

\tableofcontents

\pagebreak

\section{Development Plan}
I expect pre-release development to basically take place in three stages.
I don't expect to confine
myself to these stages, but I think they will help structure my development. Currently
in the first stage, maybe like 50\% of the way through it.

\subsection{Stage 1}
First is the prototyping stage, where I simply try to implement the relevant features
of the game. Building combat mechanics, physics, networking, all that sort of stuff.
The key is functionality, not aesthetics. Animations and models will play a role in this stage,
but only in basic form. All art will be placeholder or lacking. UI is solely meant to provide an
interface between the user and functionality, and does not need to be pretty.
Checklist for this phase:
\begin{itemize}
    \item Networking
    \item Physics
    \item Auto attacking
    \item Sample Powers (one of each type)
    \item Items
    \item Robust NPC/player deaths
    \item Looting
    \item Learning powers from scrolls (and moving them on action bar)
    \item Basic stats functionality
    \item Basic skills functionality
    \item UI that interfaces all of the above
    \item Character model prototype and movement/attack animations
    \item Test connections on more than one device
    \item NPC AI
    \item Research necessary next steps such as art styles, blender,
    music composition, procedural generation
\end{itemize}
At the end of this phase, this will not be a game, it will be more like a blueprint for a game.
Should also consider closing the source code after declaring this phase to be done.

\subsection{Stage 2}
Second is the content generation stage. The basic idea here is to get a minimal working
example for the game. Once the basic prototypes and mechanics are nailed down,
it's time to start extending them into actual content used to build the world.
A necessary transition step here will be reconsidering the database. I don't think
it will be good to just use json files for everything in the final product, so the first
step before creating content will be to improve this. Since the plan is to make use of procedural
generation to make content, there will need to be a lot of time spent making this work during
this stage. Modeling, animations, and art will be a big part of this stage, but it will be
important to balance creating art with generating content. UI will probably not be a big
part of this phase, since the UI is mostly attached to the functionality.
Checklist for this phase:
\begin{itemize}
    \item Reconsider/improve database
    \item Create or generate world
    \item Create or generate items
    \item Create or generate NPCs
    \item Create powers
    \item Make physics more robust to the world, and consider improving the feel of movement.
    \item Create launch screen for client and server
    \item Implement save system
    \item Add more models and character animations
    \item Add animations for powers (mostly just particles)
    \item Explore art style and maybe experiment with procedural art
    \item Add real art to the UI
    \item Start composing music and making sound effects
    \item Improve network security/reliability
\end{itemize}
At the end of this stage, there should be a playable but incomplete game.
I should place a high standard on the quality of art entering the game. At the end of this stage,
it should look like a marketable product. It doesn't need to be a finished product, but I should
be able to release a Steam page and be able to find playtesters.

\subsection{Stage 3}
Third is the release stage. The goal here is to enter alpha and push out a finished product.
This is far-out still, so I'm guaranteed to miss a lot here, but I'm expecting some things to
be certain.
Checklist for this phase:
\begin{itemize}
    \item Create Steam page and market the game
    \item Improve quality of assets as needed
    \item Improve game balance
    \item Consider outsourcing cloud bandwidth to allow players to host servers remotely
    \item Finish composing music
\end{itemize}

\section{Code Infrastructure}
This section describes the big-picture structure of the code.

Where possible, I try to adhere to downward dependency as much as possible. Basically, a file
should only have access to objects lower than it in the dependency tree. For example, \codeword{Character}
should not store its \codeword{controller}. While this can be more convenient to use, it typically makes a
big mess of tightly coupled spaghetti code. Ownership becomes unclear, and there is no clear dependence
(because the dependence is what was hacked away). Adhering to the downward dependence gives the codebase
a much richer structure, making it more complex but less complicated (counterintuitively).

In particular, storing higher level objects makes cleanup a lot messier. The main exception
to this is function arguments - as long as the higher level object is not stored, it doesn't get
a strong reference, so it won't impact cleanup. So, I am much more lenient with this type of tight
coupling, especially with the lower-level game logic. For example, a lot of \codeword{Item} functions rely
on \codeword{Character} objects, but \codeword{Character} relies on \codeword{Item} objects because
the \codeword{Character} stores inventory and equipment, which contain \codeword{Items}. This type
of tight coupling is pretty forgivable, especially in Python. The cost of avoiding it seems to outweigh
the benefits to me, so I choose to utilize it. So the general rule is that if an object stores another
object, it should (be able to) import the lower level object's file. If it can't due to circular import,
that means the code is too tightly coupled and needs refactoring.

The other guiding principle is to keep differing behavior between the client and server as disjoint as possible.
The client shouldn't even have access to the server code. Early on in this project's life, I used a lot of checks
to see whether the network was being hosted or not. These should be avoided. If there's a distinction between
the client and server behavior, it should be captured by subclasses that aren't accessible to one another.
At the same time, behavior that is truly identical between the client and server should be reused whenever
possible.

One benefit of the project having a clear dependency stack is that it gives a clear order to present the code in.
The rest of the section describes the entire dependency stack from the bottom up, with brief descriptions of the roles
of each file.
\subsection{Shared API}
\subsection{Client API}
\subsection{Server API}
\subsection{Project Root}
These are the \codeword{main.py}, \codeword{server.py}, \codeword{main_multiplayer.py}
files which pretty much just import everything necessary initialize the game. 
There is not currently any build process. This is subject to change.

The recommended way to launch the client is by simply running \codeword{main.py}, which
launches a child \codeword{server.py} process and connects to it automatically.
If you'd like to connect to the same local server on multiple clients, you can then run
\codeword{main_multiplayer.py} and press "c" to connect.

Alternatively, you may run \codeword{server.py} as its own process, and then connect
to it from \codeword{main_multiplayer.py}.

Of course, this launch process is subject to change once this becomes more of a real game.

\section{Implementation Details}
This section contains details specific to the implementation of certain modules. Anything that's technically
advanced or confusing should go in here.
\subsection{Client-Side Prediction for Player Movement}
To ensure smooth play while enforcing server-authoritative character movement,
we simulate the game physics client-side. Unfortunately, the simulation
is nondeterministic, so we need to adjust for the differences in the state.
The process for client-side prediction is as follows:\\
On every physics tick, we send the movement inputs from this tick to
the server, and then simulate the physics on the client. We store the
current position/rotation, and the ``targets'', and linearly interpolate
between them over the duration of the physics tick. This introduces a
physics tick worth of lag, but it's not noticeable and inconsequential
to the gameplay. This constitutes the ``prediction'' side of this story.

To accommodate the server updates, when we send the movement inputs, we
also include a sequence number that increments by one each physics
tick. We map the sequence number to the current target state, and
when the server sends back the state, it also sends back the current
highest sequence number it has. Of course, when the state arrives back
to the client, it's in the past, so we look back in time to what our
target state was at the retransmitted sequence number. We compute the
difference, and add it to the current target. Crucially, we add the
displacement to the \codeword{Character}'s \codeword{displacement_components}
to be processed for collision logic. Without applying the collision logic, it's easy to clip through
the world and have an irrecoverable state.

\subsection{States}
States are essentially lists of arguments that make building large objects
and sending RPCs easier.

The base State class defines the blueprint for States, but should never be initialized.
Instead, subclasses give the definition for what the State will contain, and
allow for flexibility in how they are constructed.

Every State is able to read from a \codeword{src} object, which is either a Character
or a dict (these possibilities may grow). They read based on the type, but are always
written as a list. The order of the list is defined by its \codeword{statedef}.

States can also be applied to Characters by overwriting the attributes, or by adding them
(for example, Stats).

\subsection{Physics}
Physics is probably the most technically challenging module to understand in this
repository.

There are currently three (well, 4, but I'll get to the fourth later) movement
factors. Player keyboard (WASD) movement, jumping, and gravity. Velocity
components are multiplied by the physics timestep (1/20th of a second) and then
added together, along with the displacement factors. After we obtain a single
displacement vector, we send it to the collision logic.

We first send a ray in the direction of the displacement vector.
If there's a hit, we infer whether it's a wall or not based on its y normal -
less than 0.2 means it's pretty vertical. If it is a wall, we project the
displacement vector onto the horizontal line along the wall, and treat the character
as grounded.
The formula for this is obtained by a plane intersection, the intersection of the
plane $ax + by + cz = 0$ and $y = 0$. This yields the parameterization
\[
\begin{pmatrix}
    x\\
    y\\
    z 
\end{pmatrix} =
\begin{pmatrix}
    b\\0\\-a
\end{pmatrix}s,\]
and rescaling this and multiplying by the dot product gives us the displacement
we want.

If the colliding surface is a feasible slope to walk up, then we change
our handling depending on whether we are grounded or not. If we are grounded,
then we simply overwrite the displacement with the displacement obtained
by subtracting the character position from the collision point, and
add a small ($10^{-3}$) amount of y displacement to make sure we don't
clip through.

If we are already grounded, then we walk up the slope. We do this by keeping
the $(x, z)$ direction from our original movement, and deduce the correct
$y$ from this and the plane normal. This is the same as finding the
intersection of the planes $ax + by + cz = 0$ and the plane defined by
$(0, 0, 0), (0, 1, 0), (\alpha, 0, \beta)$ (we look straight up because gravity goes
straight down), where $(\alpha, \beta)$ is the $(x, z)$ direction of our
original displacement. Then our line is defined by
\[
\begin{pmatrix}
    x\\y\\z
\end{pmatrix} = 
\begin{pmatrix}
    \alpha b\\-\beta c - \alpha a\\\beta b
\end{pmatrix}s.\]
Rescaling to match our original displacement gives us our final result.

\subsection{Login/Character Initialization}


\section{Ursina Usage}
\subsection{Common Bugs}
\begin{itemize}
    \item ``Remote attempted to call a RPC that does not exist (maybe a name typo in the source code?)''\\
        This essentially just means that an unregistered RPC was called. Unfortunately it does not give
        the name of the procedure. Usually this is fixed by importing the relevant file that contains the
        RPC definition, fixing a typo, or implementing a non-existing RPC.
\end{itemize}
\end{document}
